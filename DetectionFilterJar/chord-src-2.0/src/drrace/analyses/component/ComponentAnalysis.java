package drrace.analyses.component;

import java.io.File;
import java.io.FileInputStream;
import java.io.ObjectInputStream;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import chord.program.Program;
import joeq.Class.jq_Class;
import joeq.Class.jq_Method;
import joeq.Class.jq_NameAndDesc;

/*
 * This is a singleton class for android dummy main component analysis.
 */

public class ComponentAnalysis {
	//componentCallbacksMapFile is a file storing map of component and entry callback
	//This file is generated by Soot
	private final String componentCallbacksMapFile;
	
	//componentHandleMethodMapFile is a file storing map of component and entry handle method
	//This file is generated by Soot
	private final String componentHandleMethodMapFile;
	
	//overrideCallbacks is a map of component and override callback
	private final Map<String, HashMap<String,jq_Method>> overrideCallbacks;
	
	//allCallbacks is a map of component and all callback
	private final Map<String, HashSet<jq_Method>> allCallbacks;
	
	//componentHandleMethodMap is a map of component and its handle method in dummy main method
	private final HashMap<jq_Class, jq_Method> componentHandleMethodMap;;
	
	private static ComponentAnalysis instance;
		
	public static ComponentAnalysis getInstance(){
		if (instance == null)
			instance = new ComponentAnalysis();
		return instance;
	}
	
	private ComponentAnalysis() {
		componentCallbacksMapFile = System.getProperty("chord.componentCallbacksMap.file", "");
		componentHandleMethodMapFile = System.getProperty("chord.componentHandleMethodMap.file", "");
		
		overrideCallbacks = new HashMap<String, HashMap<String,jq_Method>>();
		allCallbacks = new HashMap<String, HashSet<jq_Method>>();
		componentHandleMethodMap = new HashMap<jq_Class, jq_Method>();
	}
	
		
	/*----------------------------------------------------------------------------------------
	 * All public methods Begins
	/*---------------------------------------------------------------------------------------*/
	public Map<String, HashMap<String,jq_Method>> getOverrideCallbacks(){
		if(overrideCallbacks.isEmpty()){
			System.out.println("Parse ComponentCallbacksMapFile Begin");
			parseComponentCallbacksMapFile();
			System.out.println("Parse ComponentCallbacksMapFile End");
		}
		assert(!overrideCallbacks.isEmpty());
		return overrideCallbacks;
	}
	
	public Map<String, HashSet<jq_Method>> getAllCallbacks(){
		if(allCallbacks.isEmpty()){
			System.out.println("Parse ComponentCallbacksMapFile Begin");
			parseComponentCallbacksMapFile();
			System.out.println("Parse ComponentCallbacksMapFile End");
		}
		assert(!allCallbacks.isEmpty());
		return allCallbacks;
	}
	
	public HashMap<jq_Class, jq_Method> getComponentHandleMethodMap(){
		if(componentHandleMethodMap.isEmpty()){
			System.out.println("Parse ComponentHandleMethodMapFile Begin");
			parseComponentHandleMethodMapFile();
			System.out.println("Parse ComponentHandleMethodMapFile End");
		}
		return componentHandleMethodMap;
	}
	/*----------------------------------------------------------------------------------------
	 * All public methods Ends
	/*---------------------------------------------------------------------------------------*/
	
	
	
	/*----------------------------------------------------------------------------------------
	 * Parse ComponentCallbacksMapFile Begins
	/*---------------------------------------------------------------------------------------*/
	// parse the componentCallbacksMapFile to generate overrideCallbacks and allCallbacks
	private void parseComponentCallbacksMapFile(){
		Map<String, Set<String>> componentCallbacksMap = getComponentCallbacksMap();
		assert(!componentCallbacksMap.isEmpty());
		for(Entry<String, Set<String>> entry : componentCallbacksMap.entrySet()){
			String componentClassName = entry.getKey();
			jq_Class componentClass = (jq_Class) Program.g().getClass(componentClassName);
			
			for(String callbackName : entry.getValue()){
				jq_Method callbackMethod = getMethodFromSootMethodSign(callbackName);
				
				String callbackND = callbackMethod.getNameAndDesc().toString();
				callbackND = callbackND.replaceAll("\\s", "");
				
				if(isOverrideCallback(callbackMethod,componentClass)){
					if (overrideCallbacks.get(componentClassName) == null)
						overrideCallbacks.put(componentClassName, new HashMap<String,jq_Method>());
					overrideCallbacks.get(componentClassName).put(callbackND,callbackMethod);
				}
				
				if (allCallbacks.get(componentClassName) == null)
					allCallbacks.put(componentClassName, new HashSet<jq_Method>());
				allCallbacks.get(componentClassName).add(callbackMethod);
			}
		}
	}
	
	//read componentCallbacksMapFile and convert it to Map format
	@SuppressWarnings("unchecked")
	private Map<String, Set<String>> getComponentCallbacksMap(){
		Map<String, Set<String>> componentCallbacksMap = new HashMap<String, Set<String>>();
		try {
			File file = new File(componentCallbacksMapFile);
			FileInputStream f;
			f = new FileInputStream(file);
			ObjectInputStream s = new ObjectInputStream(f);
			componentCallbacksMap = (Map<String, Set<String>>) s.readObject();
	        s.close();
	    } catch (Exception e) {
			e.printStackTrace();
		}
		return componentCallbacksMap;
	}
	
	//component type definition
	private final String activityType    = "android.app.Activity";
	private final String serviceType     = "android.app.Service";
	private final String providerType    = "android.content.ContentProvider";
	private final String receiverType    = "android.content.BroadcastReceiver";
	private final String applicationType = "android.app.Application";
	
	//check whether callback is a override callback of componentClass
	private boolean isOverrideCallback(jq_Method callback, jq_Class componentClass){
		jq_NameAndDesc callbackND = callback.getNameAndDesc();
		jq_Class curClass = componentClass.getSuperclass();
	    while (curClass != null) {
	    	if(curClass.getDeclaredMember(callbackND) != null)
	    		return true;
	    	if(curClass.getName().equals(activityType) ||
	    			curClass.getName().equals(serviceType) ||
	    			curClass.getName().equals(providerType) ||
	    			curClass.getName().equals(receiverType) ||
	    			curClass.getName().equals(applicationType))
	    		return false;
			curClass = curClass.getSuperclass();
		}
	    
		return false;
	}
	
	//return a jq_Method from soot method sign format
	private jq_Method getMethodFromSootMethodSign(String sootMethodSign){
		String mName;
		String mDesc;
		String cName;
		
		String s = sootMethodSign;
		
		int colonIndex = s.indexOf(":");
		cName = s.substring(1, colonIndex);
		
		String remainString = s.substring(colonIndex+2, s.length()-1);
		int spaceIndex = remainString.indexOf(" ");
		String sootReturnType = remainString.substring(0,spaceIndex);
		String methodNameAndParas = remainString.substring(spaceIndex+1 , remainString.length());
		int paraIndex = methodNameAndParas.indexOf("(");
		mName = methodNameAndParas.substring(0, paraIndex);
		String sootParasType = methodNameAndParas.substring(paraIndex+1, methodNameAndParas.length()-1);
		
		mDesc = getmDesc(sootParasType,sootReturnType);
		
		jq_Method method =  Program.g().getMethod(mName, mDesc, cName);
		assert(method != null);
		return method;
	}
	
	private String getmDesc(String sootParasType, String sootReturnType){
		String mDesc;
		
		String parasType = "";
		if(!sootParasType.equals("")){
			for (String sootParaType: sootParasType.split(",")){
				String paraType = getTypeFromSootType(sootParaType);
				parasType = parasType + paraType;
		    }
		}
		
		String returnType = getTypeFromSootType(sootReturnType);
		
		mDesc = ("(" + parasType + ")" + returnType);
		return mDesc;
	}
	
	private String getTypeFromSootType(String sootType){
		String type = "";
		String typeWithoutBrackets;
		String sootTypeWithoutBrackets = sootType;
		if(sootType.contains("[]")){
			sootTypeWithoutBrackets = sootTypeWithoutBrackets.replace("[]", "");
			type = type + "[";
		}
		
		switch(sootTypeWithoutBrackets){
			case "byte":
				typeWithoutBrackets = "B";
				break;
			case "char":
				typeWithoutBrackets = "C";
				break;
			case "double":
				typeWithoutBrackets = "D";
				break;
			case "float":
				typeWithoutBrackets = "F";
				break;
			case "int":
				typeWithoutBrackets = "I";
				break;
			case "long":
				typeWithoutBrackets = "J";
				break;
			case "short":
				typeWithoutBrackets = "S";
				break;
			case "boolean":
				typeWithoutBrackets = "Z";
				break;
			case "void":
				typeWithoutBrackets = "V";
				break;
			default:
				typeWithoutBrackets = getTypeFromSootRefType(sootTypeWithoutBrackets);
				break;
		}
		
		type = type + typeWithoutBrackets;
		return type;
	}
	
	private String getTypeFromSootRefType(String sootRefType){
		String type;
		
		String refType = sootRefType.replace(".", "/");
		type = "L" + refType + ";";
		return type;
	}
	/*----------------------------------------------------------------------------------------
	 * Parse ComponentCallbacksMapFile Ends
	/*---------------------------------------------------------------------------------------*/
	
	
	
	/*----------------------------------------------------------------------------------------
	 * Parse ComponentHandleMethodMapFile Begins
	/*---------------------------------------------------------------------------------------*/
	//parse ComponentHandleMethodMapFile and generate componentHandleMethodMap
	private void parseComponentHandleMethodMapFile(){
		Map<String, String> componentHandleMethodStringMap = getComponentHandleMethodStringMap();
		
		for(Entry<String, String> entry : componentHandleMethodStringMap.entrySet()){
			String componentClassName = entry.getKey();
			jq_Class componentClass = (jq_Class) Program.g().getClass(componentClassName);
			
			String componentHandleMethodSig = entry.getValue();
			jq_Method componentHandleMethod = getMethodFromSootMethodSign(componentHandleMethodSig);
			
			componentHandleMethodMap.put(componentClass, componentHandleMethod);
		}
	}
	
	@SuppressWarnings("unchecked")
	private Map<String, String> getComponentHandleMethodStringMap(){
		Map<String, String> componentHandleMethodMap = new HashMap<String, String>();
		try {
			File file = new File(componentHandleMethodMapFile);
			FileInputStream f;
			f = new FileInputStream(file);
			ObjectInputStream s = new ObjectInputStream(f);
			componentHandleMethodMap = (Map<String, String>) s.readObject();
	        s.close();
	    } catch (Exception e) {
			e.printStackTrace();
		}
		return componentHandleMethodMap;
	}
	/*----------------------------------------------------------------------------------------
	 * Parse ComponentHandleMethodMapFile Ends
	/*---------------------------------------------------------------------------------------*/
	
	/*
	 * getComponentType is used to check the component type
	 */
	
	public enum ComponentType {
		Application,
		Activity,
		Service,
		BroadcastReceiver,
		ContentProvider,
		NonComponent
	};
	
	public ComponentType getComponentType (jq_Class eventClass){
		jq_Class curClass = eventClass;
	    while (curClass != null) {
			System.out.println("Super Class: " + curClass.getName());
			if (curClass.getName().startsWith("java."))
				return ComponentType.NonComponent;
			
			if (curClass.getName().equals(activityType))
				return ComponentType.Activity;
			
			if (curClass.getName().equals(serviceType))
				return ComponentType.Service;
			
			if (curClass.getName().equals(providerType))
				return ComponentType.ContentProvider;
			
			if (curClass.getName().equals(receiverType))
				return ComponentType.BroadcastReceiver;
			
			if (curClass.getName().equals(applicationType))
				return ComponentType.Application;
			
			curClass = curClass.getSuperclass();
		}
	    return ComponentType.NonComponent;
	}
}
